Tags: #
***
### как работает?
- при компиляции двух программ, которые используют две одинаковые библиотеки, их исполняемые файлы каждый содержат одинаковый код библиотек;
***
#### плюсы
- при переносе программы не нужно замарачиватся по поводу бинарника;
***
#### объектный модуль
- секционный формат объектного модуля;

![[Pasted image 20220628142501.png]]
1) таблица символов - хранение всех глобальных символов, которые испльзоуются в программе;
2) таблицы релокации - содержатся пометки в каких кусках кода (в секции text) придутся написать вызов функции/инструкции, когда начнется компановка модулей, то есть мы выделяемся пространство для функций из других модулей или библиотек;
3) секция текст - реализует машинные инструкции;
4) секция данных;
***
#### соединение объектных модулей

1) имеется два объектных модуля

![[Pasted image 20220628143157.png]]

2) линковщик анализирует таблицы символов - понимает какие есть функции, глобальные перменные в объектном модуле и объединяет их в одну таблицу (таким образом одинаковые символы не дублируются);
3) относительно новой таблицы символов линковщик делает выводы, какие символы экспортируются, а какие символы неопределенные: 

	3.1.) **экспортированные символы** - в секции text есть какие-то глобальные фукнции, которые объявлены, как стандартные функции (не static), и они будут видны во всех других функциях вашей объединенной программы;
	3.2.) **неопределенные символы** - функции, которые мы используем от других модулей. символ будет искаться в остальных модулях;
	
 а далее создает ссылки, где они будут распологаться;

![[Pasted image 20220628145136.png]]

***
#### объединение со статической библиотекой
1) у нас есть объектный модуль и статическая библиотека 
(это архив с разрешением .a, то есть библиотека - это огромный объектный модуль)

![[Pasted image 20220628145635.png]]

2) если при компиляции он не находит объектные модули, где расположены нужные символы, то он подключает библиотеки (libc), которые предоставляет компилятор;
3) в библиотеке будет расположен индекс, относительно которого мы будем искать нужный наш модуль (напрмер, в нашем случае printf.o) и забираем его;

#### компиляция статической библиотеки
![[Pasted image 20220628152212.png]]
1) доводим файлы до объектных модулей;
2) с помощью утилиты ar rc формируем библиотеку (в названии библиотеке всегда используем в начале lib);
	2.1. ar - архив
	2.2. rc -  создать рекурсивно;
3) после получения библиотеки можно написать программу, которая ее использует, для этого:
	3.1. включить заголовочный файл;
	3.2. -L. --Imyname - где искать библиотеки нестандартные, а точнее в текущем каталоге библеотеку myname


#### Zero_Link
- 
***
### Links
Up:

Down: [[6.5.1..статические библиотеки в linux -- практика]]


