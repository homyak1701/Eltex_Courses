Tags: #
***
###
#### --функции--
### 1) fork()
1) прототип

	 ![[Pasted image 20220718223520.png]]
2) описание
	- fork() создает новый процесс, дублируя вызывающий процесс. Новый процесс называется дочерним процессом. Вызывающий процесс называется родительским процессом. Во время fork() оба пространства памяти имеют одинаковое содержимое.
	![[Pasted image 20220719211850.png]] ![[Pasted image 20220719211904.png]]
	- Дочерний процесс и родительский процесс выполняются в разных областях памяти. Во время fork() оба пространства памяти имеют одинаковое содержимое. Запись в память, сопоставление файлов (mmap(2)) и отмена сопоставления (munmap(2)), выполняемые одним из процессов, не влияют на другой.
	- нужен для того, чтобы не создавать новые дескрипторы;

3) дочерний процесс наследует:

	- сегменты кода, данных и стека программы;
	-   таблицу файлов, в которой находятся состояния флагов дескрипторов файла, указывающие, читается ли файл или пишется. Кроме того, в таблице файлов содержится текущая позиция указателя записи-чтения;
	-   рабочий и корневой каталоги;
	-   реальный и эффективный номер пользователя и номер группы;
	-   приоритеты процесса (администратор может изменить их через nice);
	-   контрольный терминал;
	-   маску сигналов;
	-   ограничения по ресурсам;
	-   сведения о среде выполнения;
	-   разделяемые сегменты памяти.

4) Потомок не наследует от родителя следующих признаков:

	-   идентификатора процесса (PID, PPID);
	-   израсходованного времени ЦП (оно обнуляется);
	-   сигналов процесса-родителя, требующих ответа;
	-   блокированных файлов (record locking).

	5) возвратное значение: 
	
		- В случае успеха родительскому процессу возвращается PID дочернего процесса, а дочернему — 0. В случае сбоя в родительском процессе возвращается -1, дочерний процесс не создается, а errno устанавливается соответствующим образом.

### 2) wait()
1) прототип

	![[Pasted image 20220718225051.png]]
2) описание
	- Эти системные вызовы используются для ожидания изменений состояния дочернего процесса вызывающего процесса и получения информации о дочернем элементе, чье состояние изменилось. 
	- Изменением состояния считается: 
		- дочерний процесс завершен; 
		- дочерний процесс был остановлен по сигналу; 
		- дочерний процесс был возобновлен по сигналу. 
	
	В случае завершенного дочернего процесса выполнение ожидания позволяет системе высвободить ресурсы, связанные с дочерним процессом; если ожидание не выполняется, то завершившийся потомок остается в состоянии "зомби"

3) возвращенное значение
	- В случае успешного выполнения **wait**() возвращает ID процесса завершившегося потомка; при ошибке возвращается -1.

### 3) exec()
- Функция exec() (execute) загружает и запускает другую программу. Таким образом, новая программа полностью замещает текущий процесс. Новая программа начинает свое выполнение с функции main. Все файлы вызывающей программы остаются открытыми. Они также являются доступными новой программе. Используется шесть различных вариантов функций exec.
	
	<unistd.h>
	int execl(char *name, char *arg0, ... /*NULL*/);
	int execv(char *name, char *argv[]);
	int execle(char *name, char *arg0, ... /*,NULL,
	           char *envp[]*/);
	int execve(char *name, char *arv[], char *envp[]);
	int execlp(char *name, char *arg0, ... /*NULL*/);
	int execvp(char *name, char *argv[]);
	
	Вызов exec происходит таким образом, что переданная в качестве аргумента программа загружается в память вместо старой, которая вызвала exec. Старой программе больше не доступны сегменты памяти, которые перезаписаны новой программой.
	
	Суффиксы l, v, p, e в именах функций определяют формат и объем аргументов, а также каталоги, в которых нужно искать загружаемую программу:
	
	-   l (список). Аргументы командной строки передаются в форме списка arg0, arg1.... argn, NULL. Эту форму используют, если количество аргументов известно;
	-   v (vector). Аргументы командной строки передаются в форме вектора argv[]. Отдельные аргументы адресуются через argv [0], argv [1]... argv [n]. Последний аргумент (argv [n]) должен быть указателем NULL;
	-   p (path). Обозначенный по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды PATH;
	-   e (среда). Функция ожидает список переменных среды в виде вектора (envp []) и не использует текущей среды.


### 4) clone()
1) прототип
![[Pasted image 20220719143652.png]]
2) описание
	- В отличие от fork, **clone**() позволяет процессу-потомку использовать некоторые части контекста выполнения совместно с вызывающим процессом, например: область памяти, таблица файловых дескрипторов и таблица обработчиков сигналов.
	- Одним из вариантов использования вызова **clone**() является реализация потоков: несколько потоков управления в программе, выполняющиеся одновременно в общем пространстве памяти. 
3) аргументы:
	1) Когда процесс-потомок создаётся с помощью clone(), он запускает функцию fn(arg). Это отличается от fork, где выполнение продолжается в потомке от точки вызова fork. Аргумент fn является указателем на функцию, которая вызывается процессом-потомком в начале своего выполнения. Аргумент arg передаётся функции fn.
	2) Аргумент _child_stack_ задаёт положение стека, используемого процессом-потомком. Так как процесс-потомок и вызывающий процесс могут использовать общую память, процесс-потомок не может выполняться в том же стеке, что и вызывающий процесс. Поэтому вызывающий процесс должен установить пространство памяти для стека процесса-потомка и передать указатель на это пространство в вызове **clone**(). Стеки растут вниз для всех процессоров, на которых работает Linux (за исключением процессоров HP PA), так что _child_stack_, обычно, указывает на наибольший адрес в пространстве памяти, которое устанавливается для стека процесса-потомка.
	3) Младший байт _flags_ содержит номер _сигнала завершения_, который посылается родителю, когда работа потомка завершается.
		(флаги посмотреть по man)

### 5) atexit()
1) прототип
	![[Pasted image 20220719145130.png]]
2) описание
	- Функция atexit() регистрирует данную функцию для вызова при нормальном завершении процесса либо через exit(), либо через возврат из функции main() программы. Зарегистрированные таким образом функции вызываются в порядке, обратном их регистрации; никакие аргументы не передаются.

### 6) waitpid()
1) прототип
![[Pasted image 20220719160136.png]]
2) Данные системные вызовы используются для ожидания изменения состояния процесса-потомка вызвавшего процесса и получения информации о потомке, чьё состояние изменилось. Сменой состояния считается: прекращение работы потомка, останов потомка по сигналу, продолжение работы потомка по сигналу.
3) аргументы 
	- первый 
	![[Pasted image 20220719160413.png]]
	- третий: Значение _options_ создается путем логического сложения нескольких следующих констант
		**WNOHANG**
		означает немедленное возвращение управления, если ни один дочерний процесс не завершил выполнение.
		
		**WUNTRACED**
		означает возврат управления и для остановленных (но не отслеживаемых) дочерних процессов, о статусе которых еще не было сообщено. Статус для отслеживаемых остановленных подпроцессов также обеспечивается без этой опции.
		
		(Только для параметров Linux, смотрите разделы ниже.)
		
		Если _status_ не равен **NULL**, то функции **wait** и **waitpid** сохраняют информацию о статусе в переменной, на которую указывает _status_. Этот статус можно проверить с помощью нижеследующих макросов (они принимают в качестве аргумента буфер (типа int), --- а не указатель на буфер!):
		
		**WIFEXITED(**_status_**)**
		не равно нулю, если дочерний процесс успешно завершился.
		
		**WEXITSTATUS(**_status_**)**
		возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс. Эти биты могли быть установлены в аргументе функции **exit()** или в аргументе оператора **return** функции **main()**. Этот макрос можно использовать, только если **WIFEXITED** вернул ненулевое значение.
		
		**WIFSIGNALED(**_status_**)**
		возвращает истинное значение, если дочерний процесс завершился из-за необработанного сигнала.
		
		**WTERMSIG(**_status_**)**
		возвращает номер сигнала, который привел к завершению дочернего процесса. Этот макрос можно использовать, только если **WIFSIGNALED** вернул ненулевое значение.
		
		**WIFSTOPPED(**_status_**)**
		возвращает истинное значение, если дочерний процесс, из-за которого функция вернула управление, в настоящий момент остановлен; это возможно, только если использовался флаг **WUNTRACED** или когда подпроцесс отслеживается.
	
		**WSTOPSIG(**_status_**)**
		возвращает номер сигнала, из-за которого дочерний процесс был остановлен. Этот макрос можно использовать, только если **WIFSTOPPED** вернул ненулевое значение.

### 7) on_exit
1) прототип
![[Pasted image 20220719145534.png]]
2) описание
	- Функция on_exit() регистрирует данную функцию для вызова при нормальном завершении процесса, будь то через exit(3) или через возврат из main() программы. В функцию передается аргумент состояния, полученный при последнем вызове exit(3), и аргумент arg из on_exit().

### 8) getpid() getppid()
![[Pasted image 20220719160625.png]]

### 9) nice()
1) прототип
	![[Pasted image 20220719160828.png]]
2) описание
- **nice** добавляет значение аргумента _inc_ к значению приоритета nice вызывающего процесса (большее значение nice означает меньший приоритет). Только суперпользователь может задавать отрицательные значения или определять увеличение приоритета.

### 10) setpriority() getpriority()
![[Pasted image 20220719161048.png]]

- описание:

Вызовом **getpriority** можно получить и вызовом **setpriority** можно установить приоритет планировщика для процесса, группы процесса или пользователя в зависимости от заданных значений _which_ и _who_. _Which_ может принимать одно из значений **PRIO_PROCESS**, **PRIO_PGRP**, или **PRIO_USER**, а _who_ интерпретируется в зависимости от _which_ (идентификатор процесса для **PRIO_PROCESS**, группы процесса для **PRIO_PGRP**, и идентификатор пользователя для **PRIO_USER**). Нулевое значение для _who_ означает (соответственно) вызывающий процесс, группу вызывающего процесса или реальный идентификатор пользователя вызывающего процесса. _Prio_ - это значение в диапазоне от -20 до 20 (см. замечания ниже). По умолчанию приоритет равен 0; более низкие значения соответствуют большему приоритету, который уделяет задаче планировщик.

Вызов **getpriority** возвращает наивысший приоритет (наименьшее числовое значение), из приоритетов всех указанных процессов. Вызов **setpriority** устанавливает приоритеты всех указанных процессов в заданное значение. Только суперпользователь может устанавливать приоритет ниже нуля.

***
- **rk()** - создание нового процесса
- **ecve()** - уничтожает существующие сегменты текста, данных, стека и кучи, заменяя их новыми сегментами, основанными на коде новой программы. (_Все эти функции имеют имена, начинающиеся со строки exec, и там, где различия не имеют значения, мы будем использовать нотацию exec() для общего обозначения этих функций._)
- **setrlimit()** - поставить высший приоритет у проуесса;
####

***
#### Zero_Link
- [[00 Процесс]]
- [[00 Контекст]]
***
### Links
Up:

Down:


